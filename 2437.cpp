#include <bits/stdc++.h>
using namespace std;
int arr[1001];

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	int n; cin >> n;

	for (int i = 0; i < n; ++i)
	{
		cin >> arr[i];
	}
	sort(arr, arr + n);

	int sum = 0;
	for (int i = 0; i < n; ++i)
	{
		if (sum + 1 < arr[i]) break;
		sum += arr[i];
	}
	cout << sum + 1;
	return 0;
}
/*
1'000'000'000 10억이면 하나씩 해보는건 안될듯
만들 수 있는 모든 수를 할수도 없을 듯 2^1000

1을 만들려면 1사용
2를 만들려면 2사용
3을 만들려면 3사용 or 1, 2사용
4를 만들려면 3, 1사용 or 1, 1, 2
5를 만들려면 3, 2사용 or 1, 1, 3 사용
자기무게 이하의 추를 사용한다.

누적합이 현재원소 이상인 경우

a0 <= S-1 + 1
a는 1뿐이다.

5

추를 쌓았을  때 a0이하의 모든 수를 만들 수 있다.

만들 수 없는 무게가  M + 1이면
만들수 있는 무게는 1 ~ M이다.

다음 추의 무게 k가 M보다 작으면
1 ~ M+k 까지 된다.

다음 추의 무게 k가 M보다 1 크면
1 ~ M 다음에 k, k + 1, k + 2....k + M까지 되서 총 1 ~ m + k가 되는거임
물론 더 작아도 같고.

근데 k가 M보다 2이상 크면?

1 ~ M 다음에 "M + 1" , k, k + 1

저 사이에 M + 1은 우리가 만들수 없다.

만들수 있는 무게의 범위는 어떻게 아는가 하면
일단 M은 당연히 추의 총 무게의 합일것이다.
그 사이가 문제인데

귀납법으로 가정하여 풀이한것같다.

초기의 누적합이 0이라면 다음 추의 무게가 0 + 1 이하이어야 0 ~ k가 가능하다.

1짜리 무게 추가있다면
누적합은 
...의 구멍이 생김 이때 M + 1가 만들수 없는 무게임



*/